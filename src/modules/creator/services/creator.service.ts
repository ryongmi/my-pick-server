import { Injectable, Logger, Inject, HttpException, forwardRef } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';

import { EntityManager, In, UpdateResult, FindOptionsWhere, Not } from 'typeorm';
import { plainToInstance } from 'class-transformer';

import type { PaginatedResult } from '@krgeobuk/core/interfaces';

import { UserSubscriptionService } from '@modules/user-subscription/index.js';
import { ContentService } from '@modules/content/index.js';
import { VideoSyncStatus, SyncStatus } from '@common/enums/index.js';

import { CreatorRepository } from '../repositories/index.js';
import { CreatorEntity, CreatorPlatformEntity } from '../entities/index.js';
import {
  CreatorSearchQueryDto,
  CreatorSearchResultDto,
  CreatorDetailDto,
  CreateCreatorDto,
  UpdateCreatorDto,
  CreatorPlatformDto,
  AddPlatformDto,
  UpdatePlatformDto,
} from '../dto/index.js';
import { CreatorException } from '../exceptions/index.js';

import { CreatorPlatformService } from './creator-platform.service.js';

interface CreatorFilter {
  name?: string;
  category?: string;
  isVerified?: boolean;
}

@Injectable()
export class CreatorService {
  private readonly logger = new Logger(CreatorService.name);

  constructor(
    private readonly creatorRepo: CreatorRepository,
    private readonly creatorPlatformService: CreatorPlatformService,
    private readonly userSubscriptionService: UserSubscriptionService,
    private readonly contentService: ContentService,
    @Inject('AUTH_SERVICE') private readonly authClient: ClientProxy
  ) {}

  // ==================== PUBLIC METHODS ====================

  // Í∏∞Î≥∏ Ï°∞Ìöå Î©îÏÑúÎìúÎì§ (BaseRepository ÏßÅÏ†ë ÏÇ¨Ïö©)
  async findById(creatorId: string): Promise<CreatorEntity | null> {
    return this.creatorRepo.findOneById(creatorId);
  }

  async findByIdOrFail(creatorId: string): Promise<CreatorEntity> {
    const creator = await this.findById(creatorId);
    if (!creator) {
      this.logger.warn('Creator not found', { creatorId });
      throw CreatorException.creatorNotFound();
    }
    return creator;
  }

  async findByIds(creatorIds: string[]): Promise<CreatorEntity[]> {
    if (creatorIds.length === 0) return [];

    return this.creatorRepo.find({
      where: { id: In(creatorIds) },
      order: { createdAt: 'DESC' },
    });
  }

  async findByCategory(category: string): Promise<CreatorEntity[]> {
    return this.creatorRepo.find({
      where: { category },
      order: { createdAt: 'DESC' },
    });
  }

  async findByAnd(filter: CreatorFilter = {}): Promise<CreatorEntity[]> {
    const where: FindOptionsWhere<CreatorEntity> = {};

    if (filter.name) where.name = filter.name;
    if (filter.category) where.category = filter.category;
    if (typeof filter.isVerified === 'boolean') where.isVerified = filter.isVerified;

    // ÌïÑÌÑ∞ ÏóÜÏúºÎ©¥ Ï†ÑÏ≤¥ Ï°∞Ìöå
    if (Object.keys(where).length === 0) {
      return this.creatorRepo.find();
    }

    return this.creatorRepo.find({ where });
  }

  async findByOr(filter: CreatorFilter = {}): Promise<CreatorEntity[]> {
    const { name, category, isVerified } = filter;

    const where: FindOptionsWhere<CreatorEntity>[] = [];

    if (name) where.push({ name });
    if (category) where.push({ category });
    if (isVerified) where.push({ isVerified });

    // ‚úÖ ÌïÑÌÑ∞ ÏóÜÏúºÎ©¥ Ï†ÑÏ≤¥ Ï°∞Ìöå
    if (where.length === 0) {
      return this.creatorRepo.find(); // Ï°∞Í±¥ ÏóÜÏù¥ Ï†ÑÏ≤¥ Ï°∞Ìöå
    }

    return this.creatorRepo.find({ where });
  }

  // Î≥µÌï© Ï°∞Ìöå Î©îÏÑúÎìúÎì§
  async searchCreators(
    query: CreatorSearchQueryDto
  ): Promise<PaginatedResult<CreatorSearchResultDto>> {
    const creators = await this.creatorRepo.searchCreators(query);

    if (creators.items.length === 0) {
      return { items: [], pageInfo: creators.pageInfo };
    }

    const creatorIds = creators.items.map((creator) => creator.id!);

    try {
      // üî• Î≥ëÎ†¨Î°ú Ï§ëÏ≤© Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (authz-server Ìå®ÌÑ¥)
      const [platforms, subscriberCounts] = await Promise.all([
        this.creatorPlatformService.findByCreatorIds(creatorIds),
        this.userSubscriptionService.getSubscriberCountsByCreatorIds(creatorIds),
      ]);

      const items = this.buildCreatorSearchResults(creators.items, platforms, subscriberCounts);

      this.logger.debug('Creator search completed with enriched data', {
        totalFound: creators.pageInfo.totalItems,
        page: query.page,
        hasNameFilter: !!query.name,
        category: query.category,
        platformsCount: platforms.length,
        subscriberCountsAvailable: Object.keys(subscriberCounts).length,
      });

      return {
        items,
        pageInfo: creators.pageInfo,
      };
    } catch (error: unknown) {
      this.logger.warn('Ïô∏Î∂Ä Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®, Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorCount: creators.items.length,
      });

      // üî• Ìè¥Î∞± Ï≤òÎ¶¨ (authz-server Ìå®ÌÑ¥)
      const items = this.buildFallbackCreatorSearchResults(creators.items);
      return {
        items,
        pageInfo: creators.pageInfo,
      };
    }
  }

  async getCreatorById(creatorId: string, userId?: string): Promise<CreatorDetailDto> {
    try {
      const creator = await this.findByIdOrFail(creatorId);

      // üî• ÌîåÎû´Ìèº Îç∞Ïù¥ÌÑ∞ÏôÄ Íµ¨ÎèÖ Ï†ïÎ≥¥ Î≥ëÎ†¨ Ï°∞Ìöå
      const [platforms, subscriberCount, isSubscribed] = await Promise.all([
        this.creatorPlatformService.findByCreatorId(creatorId),
        this.userSubscriptionService.getSubscriberCount(creatorId),
        userId ? this.userSubscriptionService.exists(userId, creatorId) : Promise.resolve(false),
      ]);

      // üî• ÌîåÎû´ÌèºÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ïã§ÏãúÍ∞Ñ ÏßëÍ≥Ñ
      const totalFollowerCount = platforms.reduce((sum, p) => sum + (p?.followerCount ?? 0), 0);
      const totalContentCount = platforms.reduce((sum, p) => sum + (p?.contentCount ?? 0), 0);
      const totalViews = platforms.reduce((sum, p) => sum + (p?.totalViews ?? 0), 0);

      const detailDto = plainToInstance(CreatorDetailDto, creator, {
        excludeExtraneousValues: true,
      });

      // üî• Ïã§ÏãúÍ∞Ñ ÏßëÍ≥ÑÎêú ÌÜµÍ≥Ñ Î∞è Íµ¨ÎèÖ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
      detailDto.followerCount = totalFollowerCount;
      detailDto.contentCount = totalContentCount;
      detailDto.totalViews = totalViews;
      detailDto.subscriberCount = subscriberCount;
      detailDto.isSubscribed = isSubscribed;
      detailDto.platforms = platforms;

      this.logger.debug('Creator detail fetched', {
        creatorId,
        userId,
        followerCount: totalFollowerCount,
        contentCount: totalContentCount,
        totalViews,
        subscriberCount,
        isSubscribed,
        platformCount: platforms.length,
      });

      return detailDto;
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Creator detail fetch failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
        userId,
      });
      throw CreatorException.creatorFetchError();
    }
  }

  async getCreatorPlatforms(creatorId: string): Promise<CreatorPlatformDto[]> {
    try {
      // 1. Creator Ï°¥Ïû¨ ÌôïÏù∏
      await this.findByIdOrFail(creatorId);

      // 2. ÌîåÎû´Ìèº Î™©Î°ù Ï°∞Ìöå
      const platforms = await this.creatorPlatformService.findByCreatorId(creatorId);

      // 3. ÏùëÎãµ ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
      return platforms.map((platform) => ({
        id: platform.id,
        type: platform.type,
        platformId: platform.platformId,
        url: platform.url,
        displayName: platform.displayName || '',
        followerCount: platform.followerCount,
        contentCount: platform.contentCount,
        totalViews: platform.totalViews,
        isActive: platform.isActive,
        lastSyncAt: platform.lastSyncAt,
        syncStatus: platform.syncStatus,
      }));
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Creator platforms fetch failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
      });
      throw CreatorException.creatorFetchError();
    }
  }

  // ==================== Í∂åÌïú Í≤ÄÏ¶ù Î©îÏÑúÎìú ====================

  async isCreatorOwner(creatorId: string, userId: string): Promise<boolean> {
    try {
      const creator = await this.creatorRepo.findOneById(creatorId);
      return creator?.userId === userId;
    } catch (error: unknown) {
      this.logger.warn('Creator ownership check failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
        userId,
      });
      return false;
    }
  }

  async validateCreatorOwnership(creatorId: string, userId: string): Promise<void> {
    const isOwner = await this.isCreatorOwner(creatorId, userId);
    if (!isOwner) {
      this.logger.warn('Creator access denied: not owner', {
        creatorId,
        userId,
      });
      throw CreatorException.creatorAccessDenied();
    }
  }

  async findByUserId(userId: string): Promise<CreatorEntity[]> {
    try {
      return await this.creatorRepo.find({
        where: { userId },
        order: { createdAt: 'DESC' },
      });
    } catch (error: unknown) {
      this.logger.error('Find creators by user ID failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        userId,
      });
      throw CreatorException.creatorFetchError();
    }
  }

  // ==================== Îç∞Ïù¥ÌÑ∞ ÎèôÏùò Í¥ÄÎ¶¨ Î©îÏÑúÎìú ====================

  /**
   * ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÎèôÏùò ÏÉÅÌÉú Î≥ÄÍ≤Ω
   */
  async updateDataConsent(
    creatorId: string,
    hasConsent: boolean,
    transactionManager?: EntityManager
  ): Promise<void> {
    try {
      const creator = await this.findByIdOrFail(creatorId);
      const now = new Date();

      // ÎèôÏùò ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      const consentChanged = creator.hasDataConsent !== hasConsent;

      if (!consentChanged) {
        this.logger.debug('Data consent status unchanged', {
          creatorId,
          currentConsent: creator.hasDataConsent,
          requestedConsent: hasConsent,
        });
        return;
      }

      // ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞ ÎèôÏùò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      const updateData: Partial<CreatorEntity> = {
        hasDataConsent: hasConsent,
        lastConsentCheckAt: now,
      };

      if (hasConsent) {
        // ÎèôÏùò ÏäπÏù∏ Ïãú
        updateData.consentGrantedAt = now;
        updateData.consentExpiresAt = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1ÎÖÑ ÌõÑ
      } else {
        // ÎèôÏùò Ï≤†Ìöå Ïãú - nullÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú nullÎ°ú ÏÑ§Ï†ï
        (updateData as any).consentGrantedAt = null;
        (updateData as any).consentExpiresAt = null;
      }

      await this.creatorRepo.update(creatorId, updateData);

      // ÌîåÎû´ÌèºÎ≥Ñ ÎèôÍ∏∞Ìôî ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      await this.updatePlatformSyncStatusOnConsentChange(creatorId, hasConsent, transactionManager);

      this.logger.log('Creator data consent updated successfully', {
        creatorId,
        hasConsent,
        consentGrantedAt: updateData.consentGrantedAt,
        consentExpiresAt: updateData.consentExpiresAt,
        wasChanged: consentChanged,
      });
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Creator data consent update failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
        hasConsent,
      });
      throw CreatorException.creatorUpdateError();
    }
  }

  /**
   * ÎèôÏùò ÏÉÅÌÉú ÌôïÏù∏ Î∞è ÎßåÎ£å Ï≤òÎ¶¨
   */
  async checkConsentExpiry(creatorId: string): Promise<{
    isValid: boolean;
    isExpiringSoon: boolean;
    daysUntilExpiry?: number;
  }> {
    try {
      const creator = await this.findByIdOrFail(creatorId);

      if (!creator.hasDataConsent || !creator.consentExpiresAt) {
        return { isValid: false, isExpiringSoon: false };
      }

      const now = new Date();
      const expiryDate = creator.consentExpiresAt;
      const daysUntilExpiry = Math.ceil(
        (expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );

      const isExpired = now > expiryDate;
      const isExpiringSoon = daysUntilExpiry <= 30; // 30Ïùº Ïù¥ÎÇ¥ ÎßåÎ£å ÏòàÏ†ï

      if (isExpired) {
        // ÎèôÏùò ÎßåÎ£å Ïãú ÏûêÎèôÏúºÎ°ú Ï≤†Ìöå Ï≤òÎ¶¨
        await this.updateDataConsent(creatorId, false);

        this.logger.warn('Creator consent expired and revoked', {
          creatorId,
          expiryDate: expiryDate.toISOString(),
          daysOverdue: Math.abs(daysUntilExpiry),
        });

        return { isValid: false, isExpiringSoon: false };
      }

      // ÎßàÏßÄÎßâ ÌôïÏù∏ ÏãúÏ†ê ÏóÖÎç∞Ïù¥Ìä∏
      await this.creatorRepo.update(creatorId, {
        lastConsentCheckAt: now,
      });

      this.logger.debug('Creator consent status checked', {
        creatorId,
        isValid: true,
        isExpiringSoon,
        daysUntilExpiry,
      });

      return {
        isValid: true,
        isExpiringSoon,
        daysUntilExpiry,
      };
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Consent expiry check failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
      });
      throw CreatorException.creatorFetchError();
    }
  }

  /**
   * ÎßåÎ£å ÏòàÏ†ïÏù∏ ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞Îì§ Ï°∞Ìöå
   */
  async findCreatorsWithExpiringConsent(daysThreshold = 30): Promise<CreatorEntity[]> {
    try {
      const thresholdDate = new Date();
      thresholdDate.setDate(thresholdDate.getDate() + daysThreshold);

      const creators = await this.creatorRepo
        .createQueryBuilder('creator')
        .where('creator.hasDataConsent = :hasConsent', { hasConsent: true })
        .andWhere('creator.consentExpiresAt <= :thresholdDate', { thresholdDate })
        .orderBy('creator.consentExpiresAt', 'ASC')
        .getMany();

      this.logger.debug('Found creators with expiring consent', {
        count: creators.length,
        daysThreshold,
        thresholdDate: thresholdDate.toISOString(),
      });

      return creators;
    } catch (error: unknown) {
      this.logger.error('Failed to find creators with expiring consent', {
        error: error instanceof Error ? error.message : 'Unknown error',
        daysThreshold,
      });
      throw CreatorException.creatorFetchError();
    }
  }

  /**
   * ÎèôÏùò ÏÉÅÌÉú ÏùºÍ¥Ñ Í∞±Ïã† (Ïä§ÏºÄÏ§ÑÎü¨ÏóêÏÑú ÏÇ¨Ïö©)
   */
  async batchUpdateConsentStatus(): Promise<{
    expiredCount: number;
    expiringSoonCount: number;
    totalChecked: number;
  }> {
    try {
      // ÎèôÏùòÌïú ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞ Î™®Îëê Ï°∞Ìöå
      const consentedCreators = await this.creatorRepo.find({
        where: { hasDataConsent: true },
      });

      let expiredCount = 0;
      let expiringSoonCount = 0;
      const totalChecked = consentedCreators.length;

      for (const creator of consentedCreators) {
        try {
          const status = await this.checkConsentExpiry(creator.id);

          if (!status.isValid) {
            expiredCount++;
          } else if (status.isExpiringSoon) {
            expiringSoonCount++;
          }
        } catch (error: unknown) {
          this.logger.warn('Individual consent check failed during batch update', {
            error: error instanceof Error ? error.message : 'Unknown error',
            creatorId: creator.id,
          });
        }
      }

      this.logger.log('Batch consent status update completed', {
        totalChecked,
        expiredCount,
        expiringSoonCount,
      });

      return { expiredCount, expiringSoonCount, totalChecked };
    } catch (error: unknown) {
      this.logger.error('Batch consent status update failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      throw CreatorException.creatorFetchError();
    }
  }

  // ==================== Î≥ÄÍ≤Ω Î©îÏÑúÎìú ====================

  async createCreator(dto: CreateCreatorDto, transactionManager?: EntityManager): Promise<void> {
    try {
      // 1. ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù (ÎπÑÏ¶àÎãàÏä§ Í∑úÏπô) - authz-server Ìå®ÌÑ¥ Ï†ÅÏö©
      if (dto.name && dto.category) {
        const existingCreator = await this.creatorRepo.findOne({
          where: { name: dto.name, category: dto.category },
        });

        if (existingCreator) {
          this.logger.warn('Creator creation failed: duplicate name', {
            name: dto.name,
            category: dto.category,
          });
          throw CreatorException.creatorAlreadyExists();
        }
      }

      // 2. ÏóîÌã∞Ìã∞ ÏÉùÏÑ±
      const creatorEntity = new CreatorEntity();
      Object.assign(creatorEntity, dto);

      // 3. Creator Ï†ÄÏû•
      const creator = await this.creatorRepo.saveEntity(creatorEntity, transactionManager);

      // 4. ÌîåÎû´Ìèº Ï†ïÎ≥¥ Î∞∞Ïπò ÏÉùÏÑ± Î∞è Ï†ÄÏû•
      if (dto.platforms && dto.platforms.length > 0) {
        await this.creatorPlatformService.addMultiplePlatformsToCreator(
          creator.id,
          dto.platforms,
          transactionManager
        );
      }

      // 5. ÏÑ±Í≥µ Î°úÍπÖ
      this.logger.log('Creator created successfully', {
        creatorId: creator.id,
        userId: dto.userId,
        name: dto.name,
        category: dto.category,
        platformCount: dto.platforms?.length || 0,
      });
    } catch (error: unknown) {
      // 4. ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Î°úÍπÖ
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Creator creation failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        userId: dto.userId,
        name: dto.name,
        category: dto.category,
      });

      throw CreatorException.creatorCreateError();
    }
  }

  async updateCreator(
    creatorId: string,
    dto: UpdateCreatorDto,
    transactionManager?: EntityManager
  ): Promise<void> {
    try {
      // BaseRepository ÏßÅÏ†ë ÏÇ¨Ïö© - authz-server Ìå®ÌÑ¥
      const creator = await this.creatorRepo.findOneById(creatorId);

      if (!creator) {
        this.logger.warn('Creator update failed: creator not found', { creatorId });
        throw CreatorException.creatorNotFound();
      }

      // Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Ïãú Ï§ëÎ≥µ Ï≤¥ÌÅ¨ (authz-server Ìå®ÌÑ¥)
      if (dto.name && dto.name !== creator.name) {
        const existingCreator = await this.creatorRepo.findOne({
          where: {
            name: dto.name,
            category: creator.category,
            id: Not(creatorId), // ÌòÑÏû¨ ÌÅ¨Î¶¨ÏóêÏù¥ÌÑ∞ Ï†úÏô∏
          },
        });

        if (existingCreator) {
          this.logger.warn('Creator update failed: duplicate name', {
            creatorId,
            newName: dto.name,
            category: creator.category,
          });
          throw CreatorException.creatorAlreadyExists();
        }
      }

      // ÏóÖÎç∞Ïù¥Ìä∏Ìï† ÌïÑÎìúÎßå Î≥ÄÍ≤Ω
      Object.assign(creator, dto);
      await this.creatorRepo.saveEntity(creator, transactionManager);

      this.logger.log('Creator updated successfully', {
        creatorId,
        name: creator.name,
        updatedFields: Object.keys(dto),
      });
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Creator update failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
        updatedFields: Object.keys(dto),
      });

      throw CreatorException.creatorUpdateError();
    }
  }

  async deleteCreator(creatorId: string): Promise<UpdateResult> {
    try {
      // BaseRepository ÏßÅÏ†ë ÏÇ¨Ïö© - authz-server Ìå®ÌÑ¥
      const creator = await this.creatorRepo.findOneById(creatorId);

      if (!creator) {
        this.logger.warn('Creator deletion failed: creator not found', { creatorId });
        throw CreatorException.creatorNotFound();
      }

      // üî• Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Ï†Ñ ÌôïÏù∏ Î∞è Ï†ïÎ¶¨
      const [subscriberCount, platforms] = await Promise.all([
        this.userSubscriptionService.getSubscriberCount(creatorId),
        this.creatorPlatformService.findByCreatorId(creatorId),
      ]);

      // üî• ÌîåÎû´ÌèºÎ≥Ñ ÏΩòÌÖêÏ∏† Ïàò ÏßëÍ≥Ñ
      const totalContentCount = platforms.reduce((sum, p) => sum + p.contentCount, 0);

      this.logger.log('Creator deletion initiated', {
        creatorId,
        creatorName: creator.name,
        subscriberCount,
        contentCount: totalContentCount,
        platformCount: platforms.length,
      });

      // Í¥ÄÎ†® Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏñ¥ÎèÑ ÏÜåÌîÑÌä∏ ÏÇ≠Ï†úÎ°ú ÏßÑÌñâ (Ï∞∏Ï°∞ Î¨¥Í≤∞ÏÑ± Ïú†ÏßÄ)

      const result = await this.creatorRepo.softDelete(creatorId);

      this.logger.log('Creator deleted successfully', {
        creatorId,
        name: creator.name,
        category: creator.category,
        deletionType: 'soft',
      });

      return result;
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Creator deletion failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
      });

      throw CreatorException.creatorDeleteError();
    }
  }

  /**
   * ÎèôÏùò ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú ÌîåÎû´Ìèº ÎèôÍ∏∞Ìôî ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
   */
  private async updatePlatformSyncStatusOnConsentChange(
    creatorId: string,
    hasConsent: boolean,
    transactionManager?: EntityManager
  ): Promise<void> {
    try {
      // ÎèôÏùò ÏÉÅÌÉúÏóê Îî∞Î•∏ ÎèôÍ∏∞Ìôî ÏÉÅÌÉú Í≤∞Ï†ï
      const updateData = hasConsent
        ? {
            // ÎèôÏùò ÏäπÏù∏ Ïãú: Ï†ÑÏ≤¥ Ïû¨ÎèôÍ∏∞Ìôî ÌïÑÏöî
            videoSyncStatus: VideoSyncStatus.CONSENT_CHANGED,
          }
        : {
            // ÎèôÏùò Ï≤†Ìöå Ïãú: Ï¶ùÎ∂Ñ ÎèôÍ∏∞ÌôîÎ°ú Ï†ÑÌôò (Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ï§ëÎã®)
            videoSyncStatus: VideoSyncStatus.INCREMENTAL,
          };

      // CreatorPlatformServiceÎ•º ÌÜµÌïú ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏
      await this.creatorPlatformService.updatePlatformSyncStatusByCreatorId(
        creatorId,
        updateData,
        transactionManager
      );

      this.logger.debug('Platform sync status updated for consent change', {
        creatorId,
        hasConsent,
        newSyncStatus: updateData.videoSyncStatus,
      });
    } catch (error: unknown) {
      this.logger.error('Failed to update platform sync status on consent change', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
        hasConsent,
      });
      // Ï£ºÏöî ÎèôÏùò ÏóÖÎç∞Ïù¥Ìä∏Î•º ÎßâÏßÄ ÏïäÍ∏∞ ÏúÑÌï¥ ÏòàÏô∏Î•º ÎçòÏßÄÏßÄ ÏïäÏùå
    }
  }

  // ==================== PRIVATE HELPER METHODS ====================

  // üî• Ï§ëÏ≤© Íµ¨Ï°∞Î°ú Í≤∞Í≥º ÎπåÎìú (Ïã§ÏãúÍ∞Ñ ÏßëÍ≥Ñ Í∏∞Î∞ò)
  private buildCreatorSearchResults(
    creators: Partial<CreatorEntity>[],
    platforms: CreatorPlatformEntity[],
    subscriberCounts: Record<string, number> = {}
  ): CreatorSearchResultDto[] {
    return creators.map((creator) => {
      const creatorPlatforms = platforms.filter((p) => p.creatorId === creator.id);

      // üî• ÌîåÎû´ÌèºÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ïã§ÏãúÍ∞Ñ ÏßëÍ≥Ñ
      const totalFollowerCount = creatorPlatforms.reduce((sum, p) => sum + p.followerCount, 0);
      const totalContentCount = creatorPlatforms.reduce((sum, p) => sum + p.contentCount, 0);
      const totalViews = creatorPlatforms.reduce((sum, p) => sum + p.totalViews, 0);
      const subscriberCount = subscriberCounts[creator.id!] || 0;

      return {
        id: creator.id!,
        name: creator.name!,
        displayName: creator.displayName!,
        avatar: creator.avatar || '',
        description: creator.description || undefined,
        isVerified: creator.isVerified!,
        followerCount: totalFollowerCount, // üî• Ïã§ÏãúÍ∞Ñ ÏßëÍ≥ÑÎêú ÌåîÎ°úÏõå Ïàò
        subscriberCount, // üî• Ïã§ÏãúÍ∞Ñ Í≥ÑÏÇ∞Îêú Íµ¨ÎèÖÏûê Ïàò
        contentCount: totalContentCount, // üî• Ïã§ÏãúÍ∞Ñ ÏßëÍ≥ÑÎêú ÏΩòÌÖêÏ∏† Ïàò
        totalViews: totalViews, // üî• Ïã§ÏãúÍ∞Ñ ÏßëÍ≥ÑÎêú Ï¥ù Ï°∞ÌöåÏàò
        category: creator.category!,
        tags: creator.tags || undefined,
        platforms: creatorPlatforms.map((p) => ({
          // üî• Ï§ëÏ≤© ÌîåÎû´Ìèº Ï†ïÎ≥¥
          id: p.id,
          type: p.type,
          platformId: p.platformId,
          url: p.url,
          followerCount: p.followerCount,
          contentCount: p.contentCount, // üî• ÌîåÎû´ÌèºÎ≥Ñ ÏΩòÌÖêÏ∏† Ïàò
          totalViews: p.totalViews, // üî• ÌîåÎû´ÌèºÎ≥Ñ Ï¥ù Ï°∞ÌöåÏàò
          isActive: p.isActive,
        })),
        createdAt: creator.createdAt!,
      };
    });
  }

  // üî• Ìè¥Î∞± Ï≤òÎ¶¨ Í≤∞Í≥º ÎπåÎìú (Ïã§ÏãúÍ∞Ñ ÏßëÍ≥Ñ Í∏∞Î∞ò)
  private buildFallbackCreatorSearchResults(
    creators: Partial<CreatorEntity>[]
  ): CreatorSearchResultDto[] {
    return creators.map((creator) => ({
      id: creator.id!,
      name: creator.name!,
      displayName: creator.displayName!,
      avatar: creator.avatar || '',
      description: creator.description,
      isVerified: creator.isVerified!,
      followerCount: 0, // üî• ÌîåÎû´Ìèº Îç∞Ïù¥ÌÑ∞ ÏóÜÏùÑ Îïå Í∏∞Î≥∏Í∞í
      subscriberCount: 0, // üî• Í∏∞Î≥∏Í∞íÏúºÎ°ú Ìè¥Î∞±
      contentCount: 0, // üî• ÌîåÎû´Ìèº Îç∞Ïù¥ÌÑ∞ ÏóÜÏùÑ Îïå Í∏∞Î≥∏Í∞í
      totalViews: 0, // üî• ÌîåÎû´Ìèº Îç∞Ïù¥ÌÑ∞ ÏóÜÏùÑ Îïå Í∏∞Î≥∏Í∞í
      category: creator.category!,
      tags: creator.tags || undefined,
      platforms: [], // üî• Îπà Î∞∞Ïó¥Î°ú Ìè¥Î∞±
      createdAt: creator.createdAt!,
    }));
  }

  // ==================== PLATFORM Í¥ÄÎ¶¨ Î©îÏÑúÎìú (Í¥ÄÎ¶¨Ïûê Ï†ÑÏö©) ====================

  async addPlatformToCreator(creatorId: string, dto: AddPlatformDto): Promise<void> {
    try {
      await this.creatorPlatformService.addPlatformToCreator(creatorId, dto);

      this.logger.log('Platform added to creator via admin', {
        creatorId,
        platformType: dto.type,
        platformId: dto.platformId,
      });
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Add platform to creator failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
        platformType: dto.type,
      });
      throw CreatorException.platformCreateError();
    }
  }

  async updateCreatorPlatform(platformId: string, dto: UpdatePlatformDto): Promise<void> {
    try {
      await this.creatorPlatformService.updateCreatorPlatform(platformId, dto);

      this.logger.log('Creator platform updated via admin', {
        platformId,
        updatedFields: Object.keys(dto),
      });
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Update creator platform failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        platformId,
      });
      throw CreatorException.platformUpdateError();
    }
  }

  async removeCreatorPlatform(platformId: string): Promise<void> {
    try {
      // ÌîåÎû´Ìèº Ï°¥Ïû¨ ÌôïÏù∏
      const platform = await this.creatorPlatformService.findByIdOrFail(platformId);

      // ÌîåÎû´Ìèº ÏÇ≠Ï†ú
      await this.creatorPlatformService.deleteCreatorPlatform(platformId);

      this.logger.log('Creator platform removed via admin', {
        platformId,
        creatorId: platform.creatorId,
        platformType: platform.type,
      });
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Remove creator platform failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        platformId,
      });
      throw CreatorException.platformDeleteError();
    }
  }

  async syncPlatformData(platformId: string): Promise<void> {
    try {
      // ÌîåÎû´Ìèº Ï°¥Ïû¨ ÌôïÏù∏
      const platform = await this.creatorPlatformService.findByIdOrFail(platformId);

      // ÎèôÍ∏∞Ìôî ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      await this.creatorPlatformService.updateSyncStatus(platformId, {
        syncStatus: SyncStatus.ACTIVE,
      });

      this.logger.log('Platform data sync triggered via admin', {
        platformId,
        creatorId: platform.creatorId,
        platformType: platform.type,
      });

      // TODO: Ïã§Ï†ú Ïô∏Î∂Ä API ÎèôÍ∏∞Ìôî Î°úÏßÅ Íµ¨ÌòÑ
      // - YouTube Data API Ìò∏Ï∂ú
      // - Twitter API Ìò∏Ï∂ú
      // - ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    } catch (error: unknown) {
      if (error instanceof HttpException) {
        throw error;
      }

      this.logger.error('Platform data sync failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        platformId,
      });
      throw CreatorException.platformSyncError();
    }
  }

  // ==================== ÌÜµÍ≥Ñ Î©îÏÑúÎìú ====================

  async getCreatorStatistics(creatorId: string): Promise<{
    followerCount: number;
    contentCount: number;
    totalViews: number;
  }> {
    try {
      // CreatorPlatformÏóêÏÑú followerCount Ï¥ùÌï© Í≥ÑÏÇ∞
      const platforms = await this.creatorPlatformService.findByCreatorId(creatorId);
      const followerCount = platforms.reduce(
        (sum: number, platform) => sum + (platform.followerCount || 0),
        0
      );

      // Content Í∞úÏàòÏôÄ Ï¥ù Ï°∞ÌöåÏàò Í≥ÑÏÇ∞ (TCP ÌÜµÏã† ÏÇ¨Ïö©)
      const [contentCount, totalViews] = await Promise.all([
        this.getContentCount(creatorId),
        this.getTotalViews(creatorId),
      ]);

      this.logger.debug('Creator statistics calculated', {
        creatorId,
        followerCount,
        contentCount,
        totalViews,
        platformCount: platforms.length,
      });

      return {
        followerCount,
        contentCount,
        totalViews,
      };
    } catch (error: unknown) {
      this.logger.error('Creator statistics calculation failed', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
      });

      // ÏóêÎü¨ Î∞úÏÉù Ïãú Í∏∞Î≥∏Í∞í Î∞òÌôò (ÏÑúÎπÑÏä§ ÏïàÏ†ïÏÑ±)
      return {
        followerCount: 0,
        contentCount: 0,
        totalViews: 0,
      };
    }
  }

  private async getContentCount(creatorId: string): Promise<number> {
    try {
      return await this.contentService.getContentCountByCreatorId(creatorId);
    } catch (error: unknown) {
      this.logger.warn('Failed to get content count from content service', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
      });
      return 0;
    }
  }

  private async getTotalViews(creatorId: string): Promise<number> {
    try {
      // ContentServiceÏóê Ï¥ù Ï°∞ÌöåÏàò Î©îÏÑúÎìú Ìò∏Ï∂ú
      return await this.contentService.getTotalViewsByCreatorId(creatorId);
    } catch (error: unknown) {
      this.logger.warn('Failed to get total views from content service', {
        error: error instanceof Error ? error.message : 'Unknown error',
        creatorId,
      });
      return 0;
    }
  }

  // ==================== ADMIN ÌÜµÍ≥Ñ Î©îÏÑúÎìú ====================

  async getTotalCount(): Promise<number> {
    try {
      return await this.creatorRepo.getTotalCount();
    } catch (error: unknown) {
      this.logger.error('Failed to get total creator count', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      return 0;
    }
  }
}

